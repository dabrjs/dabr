const n=n=>!!n&&n.constructor&&"Array"==n.constructor.name,t=n=>!!n&&"function"==typeof n,e=(n=null,t=new WeakMap)=>r({val:n,old:null,trans:new Set,changed:!1,isNode:!0,info:t}),r=n=>new Proxy(n,{set:a,get:o}),o=(n,t)=>"target"==t?n:n[t],a=(n,t,e)=>"val"==t&&(n.changed||((n,t)=>{let e=[],r=[];return function n(t,o){var a;if(null==t&&null==o)return!0;if(null==t&&null==o)return!0;if(isNaN(t)&&isNaN(o)&&"number"==typeof t&&"number"==typeof o)return!0;if(t===o)return!0;if("function"==typeof t&&"function"==typeof o||t instanceof Date&&o instanceof Date||t instanceof RegExp&&o instanceof RegExp||t instanceof String&&o instanceof String||t instanceof Number&&o instanceof Number)return t.toString()===o.toString();if(!(t instanceof Object&&o instanceof Object))return!1;if(t.isPrototypeOf(o)||o.isPrototypeOf(t))return!1;if(t.constructor!==o.constructor)return!1;if(t.prototype!==o.prototype)return!1;if(e.indexOf(t)>-1||r.indexOf(o)>-1)return!1;for(a in o){if(o.hasOwnProperty(a)!==t.hasOwnProperty(a))return!1;if(typeof o[a]!=typeof t[a])return!1}for(a in t){if(o.hasOwnProperty(a)!==t.hasOwnProperty(a))return!1;if(typeof o[a]!=typeof t[a])return!1;switch(typeof t[a]){case"object":case"function":if(e.push(t),r.push(o),!n(t[a],o[a]))return!1;e.pop(),r.pop();break;default:if(t[a]!==o[a])return!1}}return!0}(n,t)})(n.val,e)||(n.old=n.val,n.val=e,n.changed=!0,n.trans.forEach(t=>{t.func()&&n.trans.delete(t)}),n.changed=!1),!0),f=t=>t.map(t=>(t=>0==t&&!n(t)||!!t)(t.val)).reduce((n,t)=>n&&t,!0),s=(...r)=>{const o=r.length,a=r[o-1];let s,c;t(a)?(s=a,c=null):(s=r[o-2],c=a);const i=r.splice(0,o-1).map(t=>n(t)?t:[t]).reduce((n,t)=>n.concat(t));if(i.length>0){const n=s.length,t=[];for(let e=0;e<n;e++)t.push(i[e]);const r=e(),o=()=>{f(i)&&(r.val=s(...t.map(n=>n.val)))},a={nodes:i,func:o,ref:c};return i.forEach(n=>{const t=n.target.trans;if(!t.has(a))if(c){const n=[...t].find(n=>n.ref==c);n?(l(n),t.add(a)):t.add(a)}else t.has(a)||t.add(a)}),f(i)&&o(),{node:r,transition:a}}return null},c=(...n)=>{const{node:t}=s(...n);return t},i=(...r)=>{const o=r.length,a=r[o-1];let f,s;t(a)?(f=a,s=null):(f=r[o-2],s=a);const c=r.splice(0,o-1).map(t=>n(t)?t:[t]).reduce((n,t)=>n.concat(t));if(c.length>0){const n=f.length,t=[];for(let e=0;e<n;e++)t.push(c[e]);const r=e(),o=()=>{r.val=f(...t.map(n=>n.val))},a={nodes:c,func:o,ref:s};return c.forEach(n=>{const t=n.target.trans;if(!t.has(a))if(s){const n=[...t].find(n=>n.ref==s);n?(l(n),t.add(a)):t.add(a)}else t.has(a)||t.add(a)}),o(),{node:r,transition:a}}return null},u=(...n)=>{const{node:t}=i(...n);return t},l=n=>{n.nodes.forEach(t=>{t.target.trans.delete(n)})},p=n=>n.isNode?n:e(n),d=(n,t)=>mapN([n],n=>n[t]),h=(n,t)=>{const e=c(n,n=>n[t]);return c(e,()=>{const r=n.val;r[t]=e.val,n.val=r}),e};export{e as node,l as removeTran,d as subNode,h as subNode2,p as toNode,c as tran,s as tranRef,u as unsafeTran,i as unsafeTranRef};
