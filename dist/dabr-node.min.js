const n=(n=null,e=new WeakMap)=>t({val:n,old:null,trans:new Set,changed:!1,isNode:!0,info:e}),t=n=>new Proxy(n,{set:r,get:e}),e=(n,t)=>"target"==t?n:n[t],r=(n,t,e,r)=>"val"==t&&(n.changed||((n,t)=>{let e=[],r=[];return function n(t,o){var a;if(null==t&&null==o)return!0;if(null==t&&null==o)return!0;if(isNaN(t)&&isNaN(o)&&"number"==typeof t&&"number"==typeof o)return!0;if(t===o)return!0;if("function"==typeof t&&"function"==typeof o||t instanceof Date&&o instanceof Date||t instanceof RegExp&&o instanceof RegExp||t instanceof String&&o instanceof String||t instanceof Number&&o instanceof Number)return t.toString()===o.toString();if(!(t instanceof Object&&o instanceof Object))return!1;if(t.isPrototypeOf(o)||o.isPrototypeOf(t))return!1;if(t.constructor!==o.constructor)return!1;if(t.prototype!==o.prototype)return!1;if(e.indexOf(t)>-1||r.indexOf(o)>-1)return!1;for(a in o){if(o.hasOwnProperty(a)!==t.hasOwnProperty(a))return!1;if(typeof o[a]!=typeof t[a])return!1}for(a in t){if(o.hasOwnProperty(a)!==t.hasOwnProperty(a))return!1;if(typeof o[a]!=typeof t[a])return!1;switch(typeof t[a]){case"object":case"function":if(e.push(t),r.push(o),!n(t[a],o[a]))return!1;e.pop(),r.pop();break;default:if(t[a]!==o[a])return!1}}return!0}(n,t)})(n.val,e)||(n.old=n.val,n.val=e,n.changed=!0,n.trans.forEach(t=>{t.func()&&n.trans.delete(t)}),n.changed=!1),!0),o=n=>n.map(n=>(n=>0==n&&!(n=>!!n&&n.constructor&&"Array"==n.constructor.name)(n)||!!n)(n.val)).reduce((n,t)=>n&&t,!0),a=(n,t)=>{if(n.length>0){const e={nodes:n,func:t};return n.forEach(n=>{const t=n.target.trans;t.has(e)||t.add(e)}),o(n)&&t(),e}return null},f=(n,t,e)=>{if(t.length>0){const r={nodes:t,func:e,ref:n};return t.forEach(t=>{const e=t.target.trans;if(!e.has(r)){const t=[...e].find(t=>t.ref==n);t?(i(t),e.add(r)):e.add(r)}}),o(t)&&e(),r}return null},u=(n,t)=>a(n,()=>{o(n)&&t()}),i=n=>{n.nodes.forEach(t=>{t.target.trans.delete(n)})},s=t=>t.isNode?t:n(t),c=(t,e,r)=>{const o=n(null,r);return a(t,()=>{o.val=e()}),o},l=(t,e,r)=>{const o=n(null,r);return u(t,()=>{o.val=e()}),o},p=(n,t,e)=>c(n,()=>t(...n.map(n=>n.val)),e),d=(n,t,e)=>l(n,()=>t(...n.map(n=>n.val)),e);export{p as mapN,n as node,c as nodeT,i as removeTran,d as safeMapN,l as safeNodeT,u as safeTran,s as toNode,a as tran,f as tranRef};
