const e=e=>!!e&&e.constructor&&"Array"==e.constructor.name,n=n=>0==n&&!e(n)||!!n,t=e=>!!e&&"function"==typeof e,r=(e=null,n=new WeakMap)=>a({val:e,old:null,trans:new Set,changed:!1,isNode:!0,info:n,change:i,inTransaction:!1,delayedTransitions:null,delayedChanges:null}),a=e=>new Proxy(e,{set:s,get:o}),o=(e,n)=>"target"==n?e:e[n],s=(e,n,t)=>{if("val"==n){if(!e.changed&&!((e,n)=>{let t=[],r=[];return function e(n,a){var o;if(null==n&&null==a)return!0;if(null==n&&null==a)return!0;if(isNaN(n)&&isNaN(a)&&"number"==typeof n&&"number"==typeof a)return!0;if(n===a)return!0;if("function"==typeof n&&"function"==typeof a||n instanceof Date&&a instanceof Date||n instanceof RegExp&&a instanceof RegExp||n instanceof String&&a instanceof String||n instanceof Number&&a instanceof Number)return n.toString()===a.toString();if(!(n instanceof Object&&a instanceof Object))return!1;if(n.isPrototypeOf(a)||a.isPrototypeOf(n))return!1;if(n.constructor!==a.constructor)return!1;if(n.prototype!==a.prototype)return!1;if(t.indexOf(n)>-1||r.indexOf(a)>-1)return!1;for(o in a){if(a.hasOwnProperty(o)!==n.hasOwnProperty(o))return!1;if(typeof a[o]!=typeof n[o])return!1}for(o in n){if(a.hasOwnProperty(o)!==n.hasOwnProperty(o))return!1;if(typeof a[o]!=typeof n[o])return!1;switch(typeof n[o]){case"object":case"function":if(t.push(n),r.push(a),!e(n[o],a[o]))return!1;t.pop(),r.pop();break;default:if(n[o]!==a[o])return!1}}return!0}(e,n)})(e.val,t))if(e.inTransaction){const n=e.delayedTransitions;e.delayedChanges.add({target:e,value:t}),e.trans.forEach(e=>{n.add(e)})}else e.old=e.val,e.val=t,e.changed=!0,e.trans.forEach(e=>{e.func()}),e.changed=!1;return!0}return!1},c=e=>e.map(e=>n(e.val)).reduce((e,n)=>e&&n,!0),i=function(e){this.val=e(this.val)},l=(...n)=>{const a=n.length,o=n[a-1];let s,i,l;t(o)?(s=o,i=null,l=1):(s=n[a-2],i=o,l=2);const f=n.splice(0,a-l).map(n=>e(n)?n:[n]).reduce((e,n)=>e.concat(n));if(f.length>0){const e=s.length,n=[];for(let t=0;t<e;t++)n.push(f[t]);const t=r(),a=()=>{c(f)&&(t.val=s(...n.map(e=>e.val)))},o={nodes:f,func:a,ref:i};return f.forEach(e=>{const n=e.target.trans;if(!n.has(o))if(i){const e=[...n].find(e=>e.ref==i);e?(h(e),n.add(o)):n.add(o)}else n.has(o)||n.add(o)}),c(f)&&a(),{node:t,transition:o}}return null},f=(...e)=>{const{node:n}=l(...e);return n},u=(...n)=>{const a=n.length,o=n[a-1];let s,c;t(o)?(s=o,c=null):(s=n[a-2],c=o);const i=n.splice(0,a-1).map(n=>e(n)?n:[n]).reduce((e,n)=>e.concat(n));if(i.length>0){const e=s.length,n=[];for(let t=0;t<e;t++)n.push(i[t]);const t=r(),a=()=>{t.val=s(...n.map(e=>e.val))},o={nodes:i,func:a,ref:c};return i.forEach(e=>{const n=e.target.trans;if(!n.has(o))if(c){const e=[...n].find(e=>e.ref==c);e?(h(e),n.add(o)):n.add(o)}else n.has(o)||n.add(o)}),a(),{node:t,transition:o}}return null},d=(...e)=>{const{node:n}=u(...e);return n},h=e=>{e.nodes.forEach(n=>{n.target.trans.delete(e)})},p=e=>e.isNode?e:r(e),g=(e,n)=>f([e],e=>e[n]),y=(t,r)=>{const a=d(t,e=>n(e)?e[r]:null);return d(a,()=>{const o=t.val;if(o&&"object"==typeof o){const n=e(o)?o.slice():(s=o,Object.assign({},s));n[r]=a.val,t.val=n}else if(n(a.val)){const e={};e[r]=a.val,t.val=e}var s}),a},v=(n,t)=>{let r,a;e(t)?[r,a]=t:(r=t,a=t);const o=y(n,a);return n.target[r]=o,o},b=e=>{const n=r(e);if("object"==typeof e){new Set(Object.keys(e)).forEach(e=>{v(n,e)})}return n},E=(...n)=>{const t=n.length,r=n[t-1],a=n.splice(0,t-1).map(n=>e(n)?n:[n]).reduce((e,n)=>e.concat(n)),o=O(...a);r(),m(o)},O=(...e)=>{const n=new Set,t=new Set;e.forEach(e=>{e.target.inTransaction=!0,e.target.delayedTransitions=n,e.target.delayedChanges=t});return{nodes:e,delayedTransitions:n,delayedChanges:t}},m=e=>{const{nodes:n,delayedTransitions:t,delayedChanges:r}=e;r.forEach(({target:e,value:n})=>{e.old=e.val,e.val=n,e.changed=!0}),t.forEach(e=>{e.func()}),n.forEach(e=>{e.target.inTransaction=!1,e.target.changed=!1,e.target.delayedTransitions=null,e.target.delayedChanges=null})};export{v as addSubNode,m as endTransaction,r as node,b as nodeObj,h as removeTran,O as startTransaction,y as subNode,g as subNode1,p as toNode,f as tran,l as tranRef,E as transaction,d as unsafeTran,u as unsafeTranRef};
