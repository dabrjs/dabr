const e=e=>!!e&&e.constructor&&"Array"==e.constructor.name,n=e=>!!e&&"function"==typeof e,t=(e=null,n=new WeakMap)=>r({val:e,old:null,trans:new Set,changed:!1,isNode:!0,info:n,change:c,inTransaction:!1,delayedTransitions:null,delayedChanges:null}),r=e=>new Proxy(e,{set:o,get:a}),a=(e,n)=>"target"==n?e:e[n],o=(e,n,t)=>{if("val"==n){if(!e.changed&&!((e,n)=>{let t=[],r=[];return function e(n,a){var o;if(null==n&&null==a)return!0;if(null==n&&null==a)return!0;if(isNaN(n)&&isNaN(a)&&"number"==typeof n&&"number"==typeof a)return!0;if(n===a)return!0;if("function"==typeof n&&"function"==typeof a||n instanceof Date&&a instanceof Date||n instanceof RegExp&&a instanceof RegExp||n instanceof String&&a instanceof String||n instanceof Number&&a instanceof Number)return n.toString()===a.toString();if(!(n instanceof Object&&a instanceof Object))return!1;if(n.isPrototypeOf(a)||a.isPrototypeOf(n))return!1;if(n.constructor!==a.constructor)return!1;if(n.prototype!==a.prototype)return!1;if(t.indexOf(n)>-1||r.indexOf(a)>-1)return!1;for(o in a){if(a.hasOwnProperty(o)!==n.hasOwnProperty(o))return!1;if(typeof a[o]!=typeof n[o])return!1}for(o in n){if(a.hasOwnProperty(o)!==n.hasOwnProperty(o))return!1;if(typeof a[o]!=typeof n[o])return!1;switch(typeof n[o]){case"object":case"function":if(t.push(n),r.push(a),!e(n[o],a[o]))return!1;t.pop(),r.pop();break;default:if(n[o]!==a[o])return!1}}return!0}(e,n)})(e.val,t))if(e.inTransaction){const n=e.delayedTransitions;e.delayedChanges.add({target:e,value:t}),e.trans.forEach(e=>{n.add(e)})}else e.old=e.val,e.val=t,e.changed=!0,e.trans.forEach(e=>{e.func()}),e.changed=!1;return!0}return!1},s=n=>n.map(n=>(n=>0==n&&!e(n)||!!n)(n.val)).reduce((e,n)=>e&&n,!0),c=function(e){this.val=e(this.val)},i=(...r)=>{const a=r.length,o=r[a-1];let c,i,l;n(o)?(c=o,i=null,l=1):(c=r[a-2],i=o,l=2);const f=r.splice(0,a-l).map(n=>e(n)?n:[n]).reduce((e,n)=>e.concat(n));if(f.length>0){const e=c.length,n=[];for(let t=0;t<e;t++)n.push(f[t]);const r=t(),a=()=>{s(f)&&(r.val=c(...n.map(e=>e.val)))},o={nodes:f,func:a,ref:i};return f.forEach(e=>{const n=e.target.trans;if(!n.has(o))if(i){const e=[...n].find(e=>e.ref==i);e?(d(e),n.add(o)):n.add(o)}else n.has(o)||n.add(o)}),s(f)&&a(),{node:r,transition:o}}return null},l=(...e)=>{const{node:n}=i(...e);return n},f=(...r)=>{const a=r.length,o=r[a-1];let s,c;n(o)?(s=o,c=null):(s=r[a-2],c=o);const i=r.splice(0,a-1).map(n=>e(n)?n:[n]).reduce((e,n)=>e.concat(n));if(i.length>0){const e=s.length,n=[];for(let t=0;t<e;t++)n.push(i[t]);const r=t(),a=()=>{r.val=s(...n.map(e=>e.val))},o={nodes:i,func:a,ref:c};return i.forEach(e=>{const n=e.target.trans;if(!n.has(o))if(c){const e=[...n].find(e=>e.ref==c);e?(d(e),n.add(o)):n.add(o)}else n.has(o)||n.add(o)}),a(),{node:r,transition:o}}return null},u=(...e)=>{const{node:n}=f(...e);return n},d=e=>{e.nodes.forEach(n=>{n.target.trans.delete(e)})},h=e=>e.isNode?e:t(e),p=(e,n)=>l([e],e=>e[n]),g=(n,t)=>{const r=u(n,e=>e?e[t]:null);return u(r,()=>{const a=n.val;if(a&&"object"==typeof a){const s=e(a)?a.slice():(o=a,Object.assign({},o));s[t]=r.val,n.val=s}else if(r.val){const e={};e[t]=r.val,n.val=e}var o}),r},y=(n,t)=>{let r,a;e(t)?[r,a]=t:(r=t,a=t);const o=g(n,a);return n.target[r]=o,o},v=e=>{const n=t(e);if("object"==typeof e){new Set(Object.keys(e)).forEach(e=>{y(n,e)})}return n},b=(...n)=>{const t=n.length,r=n[t-1],a=n.splice(0,t-1).map(n=>e(n)?n:[n]).reduce((e,n)=>e.concat(n)),o=E(...a);r(),O(o)},E=(...e)=>{const n=new Set,t=new Set;e.forEach(e=>{e.target.inTransaction=!0,e.target.delayedTransitions=n,e.target.delayedChanges=t});return{nodes:e,delayedTransitions:n,delayedChanges:t}},O=e=>{const{nodes:n,delayedTransitions:t,delayedChanges:r}=e;r.forEach(({target:e,value:n})=>{e.old=e.val,e.val=n,e.changed=!0}),t.forEach(e=>{e.func()}),n.forEach(e=>{e.target.inTransaction=!1,e.target.changed=!1,e.target.delayedTransitions=null,e.target.delayedChanges=null})};export{y as addSubNode,O as endTransaction,t as node,v as nodeObj,d as removeTran,E as startTransaction,g as subNode,p as subNode1,h as toNode,l as tran,i as tranRef,b as transaction,u as unsafeTran,f as unsafeTranRef};
