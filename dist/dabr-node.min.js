const t=t=>!!t&&t.constructor&&"Array"==t.constructor.name,n=t=>!!t&&"function"==typeof t,e=(t=null,n=new WeakMap)=>r({val:t,old:null,trans:new Set,changed:!1,isNode:!0,info:n,change:c}),r=t=>new Proxy(t,{set:a,get:o}),o=(t,n)=>"target"==n?t:t[n],a=(t,n,e)=>"val"==n&&(t.changed||((t,n)=>{let e=[],r=[];return function t(n,o){var a;if(null==n&&null==o)return!0;if(null==n&&null==o)return!0;if(isNaN(n)&&isNaN(o)&&"number"==typeof n&&"number"==typeof o)return!0;if(n===o)return!0;if("function"==typeof n&&"function"==typeof o||n instanceof Date&&o instanceof Date||n instanceof RegExp&&o instanceof RegExp||n instanceof String&&o instanceof String||n instanceof Number&&o instanceof Number)return n.toString()===o.toString();if(!(n instanceof Object&&o instanceof Object))return!1;if(n.isPrototypeOf(o)||o.isPrototypeOf(n))return!1;if(n.constructor!==o.constructor)return!1;if(n.prototype!==o.prototype)return!1;if(e.indexOf(n)>-1||r.indexOf(o)>-1)return!1;for(a in o){if(o.hasOwnProperty(a)!==n.hasOwnProperty(a))return!1;if(typeof o[a]!=typeof n[a])return!1}for(a in n){if(o.hasOwnProperty(a)!==n.hasOwnProperty(a))return!1;if(typeof o[a]!=typeof n[a])return!1;switch(typeof n[a]){case"object":case"function":if(e.push(n),r.push(o),!t(n[a],o[a]))return!1;e.pop(),r.pop();break;default:if(n[a]!==o[a])return!1}}return!0}(t,n)})(t.val,e)||(t.old=t.val,t.val=e,t.changed=!0,t.trans.forEach(n=>{n.func()&&t.trans.delete(n)}),t.changed=!1),!0),s=n=>n.map(n=>(n=>0==n&&!t(n)||!!n)(n.val)).reduce((t,n)=>t&&n,!0),c=function(t){this.val=t(this.val)},f=(...r)=>{const o=r.length,a=r[o-1];let c,f,i;n(a)?(c=a,f=null,i=1):(c=r[o-2],f=a,i=2);const l=r.splice(0,o-i).map(n=>t(n)?n:[n]).reduce((t,n)=>t.concat(n));if(l.length>0){const t=c.length,n=[];for(let e=0;e<t;e++)n.push(l[e]);const r=e(),o=()=>{s(l)&&(r.val=c(...n.map(t=>t.val)))},a={nodes:l,func:o,ref:f};return l.forEach(t=>{const n=t.target.trans;if(!n.has(a))if(f){const t=[...n].find(t=>t.ref==f);t?(p(t),n.add(a)):n.add(a)}else n.has(a)||n.add(a)}),s(l)&&o(),{node:r,transition:a}}return null},i=(...t)=>{const{node:n}=f(...t);return n},l=(...r)=>{const o=r.length,a=r[o-1];let s,c;n(a)?(s=a,c=null):(s=r[o-2],c=a);const f=r.splice(0,o-1).map(n=>t(n)?n:[n]).reduce((t,n)=>t.concat(n));if(f.length>0){const t=s.length,n=[];for(let e=0;e<t;e++)n.push(f[e]);const r=e(),o=()=>{r.val=s(...n.map(t=>t.val))},a={nodes:f,func:o,ref:c};return f.forEach(t=>{const n=t.target.trans;if(!n.has(a))if(c){const t=[...n].find(t=>t.ref==c);t?(p(t),n.add(a)):n.add(a)}else n.has(a)||n.add(a)}),o(),{node:r,transition:a}}return null},u=(...t)=>{const{node:n}=l(...t);return n},p=t=>{t.nodes.forEach(n=>{n.target.trans.delete(t)})},d=t=>t.isNode?t:e(t),h=(t,n)=>i([t],t=>t[n]),g=(n,e)=>{const r=u(n,t=>t?t[e]:null);return u(r,()=>{const o=n.val;if(o&&"object"==typeof o){const s=t(o)?o.slice():(a=o,Object.assign({},a));s[e]=r.val,n.val=s}else if(r.val){const t={};t[e]=r.val,n.val=t}var a}),r},y=(n,e)=>{let r,o;t(e)?[r,o]=e:(r=e,o=e);const a=g(n,o);return n.target[r]=a,a},v=t=>{const n=e(t);if("object"==typeof t){new Set(Object.keys(t)).forEach(t=>{y(n,t)})}return n};export{y as addSubNode,e as node,v as nodeObj,p as removeTran,g as subNode,h as subNode1,d as toNode,i as tran,f as tranRef,u as unsafeTran,l as unsafeTranRef};
