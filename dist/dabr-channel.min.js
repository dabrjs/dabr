const t=t=>!!t&&"function"==typeof t,e=(t,e)=>n({get:t,ports:new Set,isChan:!0,info:e}),n=t=>new Proxy(t,{get:r,set:c}),r=(t,e)=>"target"==e?t:t[e],c=(t,e,n)=>"put"==e&&(t.get=n,t.ports.forEach(t=>{t.func()}),!0),s=(...n)=>{const r=n.length,c=n[r-1];let s,o,l;t(c)?(s=c,o=null,l=1):(s=n[r-2],o=c,l=2);const u=n.splice(0,r-l).map(t=>(t=>!!t&&t.constructor&&"Array"==t.constructor.name)(t)?t:[t]).reduce((t,e)=>t.concat(e));if(u.length>0){const t=s.length,n=[];for(let e=0;e<t;e++)n.push(u[e]);const r=e(),c={chans:u,func:()=>{const t=s(...n.map(t=>t.get));t&&(r.put=t)},ref:o};return u.forEach(t=>{const e=t.target.ports;if(!e.has(c))if(o){const t=[...e].find(t=>t.ref==o);t?(a(t),e.add(c)):e.add(c)}else e.has(c)||e.add(c)}),{chan:r,listener:c}}return null},o=(...t)=>{const{chan:e}=s(...t);return e},a=t=>{t.chans.forEach(e=>{e.target.ports.delete(t)})},l=(...e)=>{const n=e.length,r=e[n-1];let c,o,l;t(r)?(c=r,o=null,l=e.splice(0,n-1)):(c=e[n-2],o=r,l=e.splice(0,n-2));const u=s(...l,()=>{c(),a(u.listener)},o);return u};export{e as chan,o as listen,l as listenOnce,s as listenRef,a as removeListen};
