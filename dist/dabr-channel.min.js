const t=(t,n)=>r({get:t,ports:new Set,isChan:!0,info:n}),r=t=>new Proxy(t,{get:n,set:o}),n=(t,r)=>"target"==r?t:t[r],o=(t,r,n)=>"put"==r&&(t.get=n,t.ports.forEach(t=>{t.func()}),!0),c=(t,r)=>{const n={chans:t,func:r};return t.forEach(t=>{t.ports.add(n)}),n},e=(t,r,n)=>{const o={chans:r,func:n,ref:t};return r.forEach(r=>{const n=r.ports,c=[...n].find(r=>r.ref==t);c?(s(c),n.add(o)):n.add(o)}),o},s=t=>{t.chans.forEach(r=>{r.target.ports.delete(t)})},a=(t,r)=>{const n=c(t,()=>{r(),s(n)});return n},u=(r,n)=>{const o=t();return c(r,()=>{const t=n();var r;(0==(r=t)&&!(t=>!!t&&t.constructor&&"Array"==t.constructor.name)(r)||r)&&(o.put=t)}),o},f=(t,r)=>u(t,()=>r(...t.map(t=>t.get))),p=(t,r)=>f([t],t=>r(t)?t:null);export{t as chan,u as chanL,p as filterC,c as listen,a as listenOnce,e as listenRef,f as mapC,s as removeListen};
